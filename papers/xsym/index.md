#### 
1. We have to compare with NAVEX if we sell XSym as a exploit generation tool and emphasize its capability in automating built-in function modeling. However, it is infeasible to run it and we cannot do such comparison. Probability we can plugin our constraint to NAVEX's exploit generation, but NAVEX has its special design of the constraints, which is not consistent (existed) in XSym. So it does not guarantee we can reproduce the functionality of NAVEX. The comparison is still unfair. How to handle this? If we cannot handle this, there is no need to do the rest of work because we cannot show the benefits. Whether it is meaningful? And how much time would it take to reproduce?
2. I only proved that more paths can be supported with more built-in function modeled, under the assumption that our model works perfectly. My statistics come from that, because I cannot run NAVEX, I didn't use NAVEX to solve constraints. Whenever we encounter some function in the control-flow or data-flow that NAVEX did not support (based on my observation in its code), we say NAVEX cannot support that path. Actually NAVEX usually disregards the function calls that it does not support and NAVEX only count data-flow, without the control flow.
3. The implementation is suggested on PHP7 instead of PHP3. There are more PHP built-in functions in PHP 7, with around 2K core functions, and more functions when counting the PHP extensions. We can support about 300. Though our evaluation results show that we have good correctness on the functions we evaluated in PHP test suite, however, this is because the choice of the test suite-- that is, the tests in PHP engine are relative simple, and most of them are in our scope of input size. But in reality, the inputs can out of our scope. Besides, for those functions that are not evaluated as there is not test suite, they perform worse than those tested, I know this for sure. Then I think the benefits under current implementation is not enough, and further improve the methods in implementation is needed, but there must be a lot of engineering challenges. From the lab wiki, though this project takes me about 1 year, but I only started working on cross-language part since October, 2019. The previous months I all spent on taint analysis and symbolic execution on PHP. I admit that I spent too much time because I did not understand and I was not familiar with these common program analysis techniques and common limitations. To further change the implementation, I have no idea how much time I will take. If I have to reproduce NAVEX, which is written in JAVA, and deal with some problems with the tools that NAVEX is built based on, and re-implement the cross-language part, probability more than 4 months are required. Personally, I feel depressed when working on this project. I don't want to work on it anymore. It is tiring.
