### Title: Symbolic execution with SymCC: Don't interpret, compile! 

#### Summary

Symbolic execution is a useful technique for program analysis. It can be generally classified into two classes: IR-based and IR-less. The former first transforms the targeted program into a high-level IR, and the symbolic interpreter runs it together with necessary symbolic reasoning. It is relatively easier to implement but slow. The latter usually executes the unmodified machine code of the targeted program and performs run-time instrumentation. It is faster but more complex to code. This paper, thus, proposes SymCC, a compilation-based approach to take the advantages of the strengths of IR-based and IR-less methods -- easy implementation and better performance. During the compilation, SymCC reads the original LLVM IR of the program and inserts necessary symbolic reasoning operations, e.g., declare symbolic inputs, which are to call the symbolic backend provided in a SymCC's library. For the environment and external modules, SymCC can support them once they can be compiled with SymCC compiler; otherwise, SymCC simply treats them as concrete values/operations. Similar to other symbolic execution works, SymCC equips with concreteness checks to restrict invocations of symbolic backends to reduce performance overhead, i.e., the backend is invoked only when there is at least a symbolic data. SymCC can be used with its own simple symbolic backend but also can be flexibly integrated with QSYM backend, which considers better performance optimization.

The evaluation is performed on the benchmarks of prior work, closely compared with KLEE and QSYM. In term of pure execution time on concrete inputs, SymCC achieves close time to the native code compiled with clang, and outperforms other tools by over 28X. Evaluating on symbolic inputs using known (proofs of) vulnerabilities, SymCC also uses less time. SymCC also has similar coverage as QSYM and better over KLEE. Besides, SymCC does not introduce an initialization overhead, it causes an acceptable 58% compilation time overhead, and 3.4 binary size increase. Evaluation on real-world software includes known vulnerable applications OpenJPEG, and latest versions of libarchive and tcpdump, integrating with AFL. The results demonstrate that SymCC is faster than QSYM in all tested software, and detected two previously unknown vulnerabilities.

In summary, compilation-based symbolic execution can ease the implementation, and achieve higher performance. Such an approach can directly port to other languages translatable to LLVM in the current implementation and even, generally to other compiled programming languages.